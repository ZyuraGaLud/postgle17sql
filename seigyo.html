<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>技術解説：PostgreSQL 17で学ぶ同時実行制御と隔離レベル</title>
    <style>
        /* 全体設定：白背景・黒文字でシンプルに */
        body { 
            font-family: sans-serif; 
            line-height: 1.6; 
            color: #000; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px;
            background-color: #fff;
        }

        /* 見出し：装飾を最小限に */
        h1 { border-bottom: 2px solid #000; padding-bottom: 8px; }
        h2 { border-bottom: 1px solid #000; margin-top: 40px; padding-bottom: 5px; }
        h3 { margin-top: 30px; }

        /* コードブロック：枠線と余白のみ */
        pre { 
            border: 1px solid #ccc; 
            padding: 15px; 
            overflow-x: auto; 
            background: #fff;
            margin: 20px 0;
        }
        code { 
            font-family: monospace;
            font-size: 0.95em;
        }

        /* テーブル：罫線のみのシンプルな構成 */
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 20px 0; 
        }
        th, td { 
            border: 1px solid #000; 
            padding: 8px; 
            text-align: left; 
        }
        th { background-color: #f9f9f9; }

        /* 実験用セッションの識別（色を抑えた太字） */
        .session-a { color: #0055ff; font-weight: bold; }
        .session-b { color: #aa5500; font-weight: bold; }

        /* 補足説明の枠 */
        .note { 
            border: 1px solid #000; 
            padding: 15px; 
            margin: 20px 0; 
        }
    </style>
</head>
<body>

<h1>PostgreSQL 17で体感する！トランザクション隔離レベルと同時実行制御</h1>

<p>本記事では、データベースで複数のユーザーが同時にアクセスする際の整合性を保つ仕組み「同時実行制御」について解説します。PostgreSQL 17を用いて、不整合が起きる瞬間とその対策を実験・検証します。</p>

<section>
    <h2>1. 同時実行制御が必要な理由</h2>
    <p>データベースには多くのユーザーが同時にアクセスします。何の制御もなければ、データの更新が重なり、矛盾が生じてしまいます。これを防ぎ、複数の処理を順番に実行したかのように制御するのが「隔離レベル」の役割です。</p>
    
</section>

<section>
    <h2>2. 3つの異常現象 (Anomaly)</h2>
    <p>同時実行制御が不十分な場合に発生する主な問題は以下の3つです。</p>

    <h3>① ダーティリード (Dirty Read)</h3>
    <p>確定していない（COMMIT前の）書き込み途中のデータを、他の人が読んでしまう現象です。※PostgreSQLでは発生しません。</p>

    <h3>② 非再現リード (Non-repeatable Read)</h3>
    <p>同じ処理の中で2回データを読んだとき、その間に他人が更新したせいで値が変わってしまう現象です。</p>
    

    <h3>③ ファントムリード (Phantom Read)</h3>
    <p>同じ条件で検索を2回行ったとき、その間に他人が新しい行を追加したせいで、検索結果の件数が増えてしまう現象です。</p>
    
</section>

<section>
    <h2>3. 実験準備：PostgreSQL 17 セットアップ</h2>
    <p>以下のSQLを実行して、実験用のテーブルとデータを作成してください。</p>
<pre><code>CREATE TABLE accounts (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

INSERT INTO accounts VALUES (1, 'Alice', 1000), (2, 'Bob', 1000);</code></pre>

    <div class="note">
        <strong>実験方法：</strong>2つのターミナルを開き、それぞれ <code>psql</code> で接続してください。
        これらを <strong><span class="session-a">Session A</span></strong> と <strong><span class="session-b">Session B</span></strong> として扱います。
    </div>
</section>

<section>
    <h2>4. 実験1：Read Committed の挙動</h2>
    <p>デフォルト設定で「非再現リード」が発生することを確認します。</p>
    
    <table>
        <tr>
            <th>Step</th>
            <th><span class="session-a">Session A</span></th>
            <th><span class="session-b">Session B</span></th>
        </tr>
        <tr>
            <td>1</td>
            <td><code>BEGIN;</code></td>
            <td><code>BEGIN;</code></td>
        </tr>
        <tr>
            <td>2</td>
            <td><code>SELECT balance FROM accounts WHERE id = 1;</code><br>→ 1000</td>
            <td>-</td>
        </tr>
        <tr>
            <td>3</td>
            <td>-</td>
            <td><code>UPDATE accounts SET balance = 800 WHERE id = 1;</code><br><code>COMMIT;</code></td>
        </tr>
        <tr>
            <td>4</td>
            <td><strong><code>SELECT balance FROM accounts WHERE id = 1;</code></strong></td>
            <td>-</td>
        </tr>
    </table>
    <p><strong>検証結果：</strong>Session Aの2回目の読み取りでは、他人の確定した更新が反映され、値が <strong>800</strong> に変わりました。</p>
</section>

<section>
    <h2>5. 実験2：Repeatable Read の挙動</h2>
    <p>隔離レベルを上げ、処理中の値が固定されることを確認します。</p>

    <table>
        <tr>
            <th>Step</th>
            <th><span class="session-a">Session A</span></th>
            <th><span class="session-b">Session B</span></th>
        </tr>
        <tr>
            <td>1</td>
            <td><code>BEGIN ISOLATION LEVEL <strong>REPEATABLE READ</strong>;</code></td>
            <td><code>BEGIN;</code></td>
        </tr>
        <tr>
            <td>2</td>
            <td><code>SELECT balance FROM accounts WHERE id = 1;</code><br>→ 1000</td>
            <td>-</td>
        </tr>
        <tr>
            <td>3</td>
            <td>-</td>
            <td><code>UPDATE accounts SET balance = 500 WHERE id = 1;</code><br><code>COMMIT;</code></td>
        </tr>
        <tr>
            <td>4</td>
            <td><strong><code>SELECT balance FROM accounts WHERE id = 1;</code></strong></td>
            <td>-</td>
        </tr>
    </table>
    <p><strong>検証結果：</strong>Session Aの結果は <strong>1000</strong> のままです。トランザクション開始時のデータが守られています。</p>
</section>

<hr>
<p><strong>本コンテンツの作成時間：約12時間</strong></p>

</body>
</html>
