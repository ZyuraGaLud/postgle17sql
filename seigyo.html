<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>技術解説：PostgreSQL 17で学ぶ同時実行制御と隔離レベル</title>
    <style>
        body { 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            line-height: 1.8; 
            color: #000000; 
            max-width: 900px; 
            margin: 0 auto; 
            padding: 30px; 
            background-color: #ffffff;
        }
        h1 { border-bottom: 4px solid #000000; padding-bottom: 10px; color: #000000; }
        h2 { background: #f0f0f0; padding: 12px; border-left: 6px solid #000000; margin-top: 40px; color: #000000; }
        h3 { color: #000000; border-bottom: 2px solid #000000; margin-top: 30px; }
        
        pre { 
            background: #f8f9fa; 
            color: #000000; 
            padding: 20px; 
            border: 1px solid #000000; 
            border-radius: 5px; 
            overflow-x: auto; 
            line-height: 1.5;
            margin: 20px 0;
            display: block;
            width: 100%;
        }
        code { 
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
            background: #eeeeee; 
            padding: 2px 5px; 
            border-radius: 3px; 
        }
        pre code { 
            background: transparent; 
            padding: 0; 
        }

        .anomaly-box { border: 1px solid #000000; padding: 20px; border-radius: 8px; margin: 20px 0; background: #ffffff; }
        .experiment-box { border: 2px solid #000000; padding: 20px; margin: 25px 0; border-radius: 8px; background: #ffffff; }
        
        .step-table { width: 100%; border-collapse: collapse; margin: 20px 0; color: #000000; }
        .step-table th, .step-table td { border: 1px solid #000000; padding: 12px; text-align: left; }
        .step-table th { background-color: #f0f0f0; }

        .session-a { color: #0000ff; font-weight: bold; } /* 識別のため青 */
        .session-b { color: #cc6600; font-weight: bold; } /* 識別のため茶 */
        
        .note { border: 2px dashed #000000; padding: 15px; border-radius: 5px; margin: 20px 0; font-size: 0.95em; }
    </style>
</head>
<body>

<h1>トランザクション隔離レベルと同時実行制御</h1>

<p>本記事では、RDBMSにおいて複数ユーザが同時にアクセスする際にデータの整合性を保つ仕組み「同時実行制御（Concurrency Control）」を解説します。講義で学んだ基礎を一歩進め、PostgreSQL 17のコンテナ環境を使って「不整合が起きる瞬間」とその対策を実験・検証します。</p>

<section>
    <h2>1. 同時実行制御が必要な理由</h2>
    <p>データベースは、単一の処理を順番にこなすだけではありません。Webサービスや基幹システムでは、数千・数万のユーザーが <strong>同時に（並行して）</strong> データを読み書きします。ここで問題となるのが、<strong>「処理の干渉」</strong>です。</p>
    
    <p>トランザクションには、一連の処理が「完全に終わるか、全く行われないか」を保証するACID特性がありますが、複数のトランザクションが重なり合う場合、その「中間状態」が互いに見えてしまうと、計算が狂ってしまいます。</p>

    

    <p>同時実行制御の目的は、並行して動いている複数の処理を、あたかも <strong>「一つずつ順番に実行した（直列実行した）」</strong> かのような正しい結果に導くことです。性能と整合性のトレードオフを調整するのが「隔離レベル」の役割です。</p>
</section>

<section>
    <h2>2. 知っておくべき3つの異常現象 (Anomaly)</h2>
    <div class="anomaly-box">
        <h3>① ダーティリード (Dirty Read)</h3>
        <p><strong>「確定していない嘘」を読んでしまう現象です。</strong></p>
        <p>Aさんが書き込み、まだ確定（COMMIT）させていないデータを、Bさんが読み取ってしまうことを指します。Aさんが後で取り消し（ROLLBACK）た場合、Bさんは存在しないデータを基に処理をすることになります。</p>
    </div>

    <div class="anomaly-box">
        <h3>② 非再現リード (Non-repeatable Read)</h3>
        <p><strong>「読んだ値と違う」という現象です。</strong></p>
        
        <p>Aさんが値を読み取った後、Bさんがその値を更新して確定させます。Aさんがもう一度同じ値を読むと、違う値が見えてしまいます。集計処理の最中にデータが変わると計算が合わなくなります。</p>
    </div>

    <div class="anomaly-box">
        <h3>③ ファントムリード (Phantom Read)</h3>
        <p><strong>「幽霊（Phantom）のように行が現れる」現象です。</strong></p>
        
        <p>Aさんが範囲検索をした後、Bさんが新しい行を追加して確定させます。Aさんが再度同じ条件で検索すると、1回目にはいなかったはずの「新しい行」が出現します。件数集計などに影響します。</p>
    </div>
</section>

<section>
    <h2>3. 実験準備：PostgreSQL 17 環境のセットアップ</h2>
    <p>まずは PostgreSQL 17 コンテナへ接続し、以下のSQLを実行して実験用の「銀行口座テーブル」を作成してください。</p>
<pre>
-- テーブル作成
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance INT
);

-- 初期データの挿入
INSERT INTO accounts VALUES (1, 'Alice', 1000), (2, 'Bob', 1000);
</pre>
    <div class="note">
        <strong>実験方法:</strong> 2つのターミナルを立ち上げ、両方で <code>psql</code> を接続してください。青色を <strong>Session A</strong>、茶色を <strong>Session B</strong> として進めます。
    </div>
</section>

<section>
    <h2>4. 実験1：Read Committed レベルの検証</h2>
    <p>デフォルトの <code>READ COMMITTED</code> で、非再現リードが発生することを確認します。</p>
    
    <table class="step-table">
        <tr>
            <th>Step</th>
            <th><span class="session-a">Session A</span></th>
            <th><span class="session-b">Session B</span></th>
        </tr>
        <tr>
            <td>1</td>
            <td><code>BEGIN;</code></td>
            <td><code>BEGIN;</code></td>
        </tr>
        <tr>
            <td>2</td>
            <td><code>SELECT balance FROM accounts WHERE id = 1;</code><br>→ 1000</td>
            <td>-</td>
        </tr>
        <tr>
            <td>3</td>
            <td>-</td>
            <td><code>UPDATE accounts SET balance = 800 WHERE id = 1;</code><br><code>COMMIT;</code></td>
        </tr>
        <tr>
            <td>4</td>
            <td><strong><code>SELECT balance FROM accounts WHERE id = 1;</code></strong></td>
            <td>-</td>
        </tr>
    </table>

    <p><strong>検証結果:</strong> Session Aの結果が <strong>800</strong> に変わりました。これが Read Committed の挙動です。</p>
</section>

<section>
    <h2>5. 実験2：Repeatable Read による解決</h2>
    <p>隔離レベルを上げて、データが固定されることを確認します。</p>

    <table class="step-table">
        <tr>
            <th>Step</th>
            <th><span class="session-a">Session A</span></th>
            <th><span class="session-b">Session B</span></th>
        </tr>
        <tr>
            <td>1</td>
            <td><code>BEGIN ISOLATION LEVEL <strong>REPEATABLE READ</strong>;</code></td>
            <td><code>BEGIN;</code></td>
        </tr>
        <tr>
            <td>2</td>
            <td><code>SELECT balance FROM accounts WHERE id = 1;</code><br>→ 1000</td>
            <td>-</td>
        </tr>
        <tr>
            <td>3</td>
            <td>-</td>
            <td><code>UPDATE accounts SET balance = 500 WHERE id = 1;</code><br><code>COMMIT;</code></td>
        </tr>
        <tr>
            <td>4</td>
            <td><strong><code>SELECT balance FROM accounts WHERE id = 1;</code></strong></td>
            <td>-</td>
        </tr>
    </table>

    <p><strong>検証結果:</strong> 結果は <strong>1000</strong> のままです。トランザクション開始時点の「スナップショット」を維持しているため、他者の影響を受けません。</p>
</section>

<section>
    <h2>6. 理解度確認：演習ドリル</h2>
    <p>ここまでの学習内容を踏まえ、以下の問題に挑戦してみましょう。後半は実際に環境を操作して結果を確認する実戦形式です。</p>

    <h3>【問題1】理論チェック：隔離レベルと異常現象</h3>
    <p>PostgreSQL 17において、各隔離レベルで防ぐことができる（発生しない）現象の組み合わせとして正しいものを選びなさい。</p>
    <ul>
        <li>A. Read Committed レベルでは「非再現リード」を防ぐことができる。</li>
        <li>B. Repeatable Read レベルでは「ダーティリード」と「非再現リード」を防ぐことができる。</li>
        <li>C. PostgreSQLのデフォルト設定（Read Committed）では「ダーティリード」が発生する。</li>
    </ul>

    <h3>【問題2：SQLドリル】ロストアップデート（更新の紛失）の検証</h3>
    <div class="experiment-box">
        <p><strong>シナリオ：</strong> Session AとSession Bが、ほぼ同時に同じ口座に対して「100円加算する」という処理を行います。</p>
        <p><strong>実行手順：</strong></p>
        <ol>
            <li>両方のセッションで <code>BEGIN;</code> を実行。</li>
            <li><strong>Session A:</strong> <code>UPDATE accounts SET balance = balance + 100 WHERE id = 1;</code> を実行。</li>
            <li><strong>Session B:</strong> <code>UPDATE accounts SET balance = balance + 100 WHERE id = 1;</code> を実行。</li>
            <li>このとき、Session Bの画面はどうなっているか？また、その理由は？</li>
            <li><strong>Session A:</strong> <code>COMMIT;</code> を実行。この後のSession Bの変化を観察せよ。</li>
        </ol>
    </div>

    <h3>【問題3：応用】デッドロックを発生させる</h3>
    <p>2つのセッションでお互いに相手がロックしている行を更新しようとしたとき、PostgreSQLはどのようなエラーを出すでしょうか。以下の順序で試してください。</p>
    <p>1. Aがid=1を更新 → 2. Bがid=2を更新 → 3. Aがid=2を更新しようとする → 4. Bがid=1を更新しようとする</p>
</section>

<section>
    <h2>7. 演習の解答例と解説</h2>
    
    <div class="note">
        <h4>【問題1】の答え： B</h4>
        <p>PostgreSQLでは <code>READ UNCOMMITTED</code> を指定しても <code>READ COMMITTED</code> として動作するため、どのレベルでもダーティリードは発生しません。非再現リードを防ぐには <code>REPEATABLE READ</code> 以上が必要です。</p>
    </div>

    <div class="note">
        <h4>【問題2】の解説</h4>
        <p><strong>挙動：</strong> Session Bは入力待ち（ブロック）状態になり、コマンドが完了しません。<br>
        <strong>理由：</strong> 同じ行を同時に更新しようとすると、先行するトランザクションが終了するまで「行ロック」がかかるためです。Session Aが <code>COMMIT</code> した瞬間に、Bの更新が動き出します。</p>
    </div>

    <div class="note">
        <h4>【問題3】の解説</h4>
        <p>実行すると、PostgreSQLは <strong>"ERROR: deadlock detected"</strong> を出力します。これは、お互いが相手のロック解除を永遠に待ち続けてしまう状態を検知し、システムが停止するのを防ぐために一方のトランザクションを強制終了したことを示します。</p>
    </div>
</section>

<hr>
<p><strong>本コンテンツの作成時間：約12時間</strong></p>

</body>
</html>
